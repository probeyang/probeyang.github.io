<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pattern design on Sanlt,就是加了N多盐的地方</title>
    <link>https://www.sanlt.com/categories/pattern-design/</link>
    <description>Recent content in Pattern design on Sanlt,就是加了N多盐的地方</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 22 Sep 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.sanlt.com/categories/pattern-design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>三种工厂模式详解</title>
      <link>https://www.sanlt.com/post/pattern_design/simple_factory/</link>
      <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.sanlt.com/post/pattern_design/simple_factory/</guid>
      <description>工厂模式三种类型 简单工厂模式 简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。 不修改代码的话，是无法扩展的。</description>
    </item>
    
    <item>
      <title>设计模式之单例模式</title>
      <link>https://www.sanlt.com/post/pattern_design/singleton/</link>
      <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.sanlt.com/post/pattern_design/singleton/</guid>
      <description>单例模式有两种 延迟方式 急切方式 下面我们详细介绍两种方式。 延迟方式 利用私有的构造器，只有单例类内部才可以调用构造器。 延迟方式的问题在于每次实例</description>
    </item>
    
    <item>
      <title>设计模式之模板方法模式</title>
      <link>https://www.sanlt.com/post/pattern_design/template_method/</link>
      <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.sanlt.com/post/pattern_design/template_method/</guid>
      <description>定义 模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某</description>
    </item>
    
    <item>
      <title>设计模式之状态模式</title>
      <link>https://www.sanlt.com/post/pattern_design/state_pattern/</link>
      <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.sanlt.com/post/pattern_design/state_pattern/</guid>
      <description>定义 状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for Sta</description>
    </item>
    
    <item>
      <title>设计模式之策略模式</title>
      <link>https://www.sanlt.com/post/pattern_design/strategy_pattern/</link>
      <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.sanlt.com/post/pattern_design/strategy_pattern/</guid>
      <description>定义 策略（Strategy）模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 示例 我们用一个实</description>
    </item>
    
  </channel>
</rss>